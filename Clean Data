library(MASS)
library(leaps)
library(ggplot2)

setwd("E:\\R\\final")

# các biểu đồ chạy ra phải zoom lên mới đọc hiểu được 

########## XỬ LÝ DỮ LIỆU VANG ĐỎ ##########

redDat = read.table("winequality-red.csv", sep = ",", header = T)
View(redDat)
model1 = lm(quality ~ ., data = redDat)
u = summary(model1)$r.squared

## Liệt kê thông số 
dim(redDat) # lấy tổng số bản ghi và số trường dữ liệu 
sapply(redDat, class) # lấy kiểu của từng trường dữ liệu 
summary(redDat) # thống kê tóm tắt từng trường dữ liệu (min, Q1, median, mean, Q3, max) -> IQR = Q3 - Q1 


## Xem xét dữ liệu dưới 3 góc độ  
# sử dụng boxplot (biểu đồ hộp chia theo các "tứ phân vị") để xem sự phân bố dữ liệu của từng trường (link boxplot: https://bom.so/pjtUet)
oldpar = par(mfrow = c(2,6))  # par() dùng để vẽ nhiều biểu đồ cùng lúc, mfrow = c(2,6) ~ vẽ trên 2 hàng, 6 biểu đồ/hàng 
for ( i in 1:11 ) {
  boxplot(redDat[[i]])
  mtext(names(redDat)[i], cex = 0.7, side = 1, line = 2) 
    # hiện tên trường, các thông số bên dưới để format cho đẹp 
    # cex = 0.7: kích cỡ chữ ở mức 70% so với default 
    # side = 1: hiện chữ phía dưới biểu đồ
    # line = 2: chữ cách ra một dòng so với biểu đồ    
}

# sử dụng scatter plot matrix (ma trận đồ thị phân tán) để đánh giá sự tương quan giữa các chất (link scatter plot: https://bom.so/6RU3HJ)
pairs(redDat[, -grep("quality", colnames(redDat))]) # df[,-grep..] là lấy ra bộ dữ liệu đã bỏ đi cột "quality"

# sử dụng truehist() từ MASS, cũng là histogram (biểu đồ tần suất) nhưng có thêm ước tính mật độ xác suất (tần suất/tổng phần tử)
oldpar = par(mfrow = c(3,4))
for ( i in 1:12 ) {
  truehist(redDat[[i]], xlab = names(redDat)[i], col = 'lightgreen', main = paste("Average =", signif(mean(redDat[[i]]),3)))
    # signif(x, 3): làm tròn giá trị x đến 3 chữ số sau dấu thập phân   
}


## Tìm chính xác vị trí outlier (giá trị bất thường) dựa trên 2 tiêu chuẩn (link: https://bom.so/b1M3Up)
outliers = c()

# Tiêu chuẩn 1: nằm ngoài khoảng A = [Q1 - 1.5 * IQR, Q3 + 1.5 * IQR])
for ( i in 1:11 ) {
  b1 = boxplot.stats(redDat[[i]]) # link hàm boxplot.stats(): https://bom.so/Hh6iyf
  stats = b1$stats # dãy 5 gtri (Q1 - 1.5 * IQR, Q1, median, Q3, Q3 + 1.5 * IQR) tương ứng với trường 
  
  # tìm các hàng chứa outlier quá thấp mà chưa có trong mảng outliers 
  bottom_outlier_rows = which(redDat[[i]] < stats[1])
  outliers = c(outliers , bottom_outlier_rows[ !bottom_outlier_rows %in% outliers ] )
  
  # tìm các hàng chứa outlier quá cao mà chưa có trong mảng outliers
  top_outlier_rows = which(redDat[[i]] > stats[5])
  outliers = c(outliers , top_outlier_rows[ !top_outlier_rows %in% outliers ] )
}

model2 = lm(quality ~ ., data = redDat[-outliers,])
v = summary(model2)$r.squared
# r-Squared: a statistical measure in a regression model that determines the proportion of variance in the dependent variable that can be explained by the independent variable. 
# --> r-squared shows how well the data fit the regression model (the goodness of fit).

# Tiêu chuẩn 2: căn cứ vào khoảng cách Cook 
# Note: trong nhiều tài liệu gọi loại giá trị bất thường này là influential observation/point ~ các giá trị nằm trong khoảng A nhưng ảnh hưởng  
# trực tiếp mạnh mẽ đến hệ số góc/độ dốc (slope) của đường biểu diễn trong bài toán hồi quy tuyến tính -> ảnh hưởng kết quả đánh giá 
# link tham khảo thêm (Chi tiết về cách loại bỏ influential points bằng Cooks distance: https://bom.so/ZJO9YV)

mod = lm(quality ~ ., data = redDat) # tạo một mô hình hồi quy tuyến tính 
      # (quality ~ . tức là biểu diễn quality dưới dạng hàm số của tất cả các biến còn lại)
cooksd = cooks.distance(mod) 
plot(cooksd, pch = "*", cex = 2, main = "Influential Obs by Cooks distance")
abline(h = 4*mean(cooksd, na.rm = T), col = "red")

coutliers = as.numeric(rownames(redDat[cooksd > 4 * mean(cooksd, na.rm = T), ]))
      # có nhiều loại ngưỡng cho việc cut-off bằng Cook distance, có thể dùng 1 trong những công thức sau:
            # 4/n (most commonly seen)
            # 4/(n - k - 1) , n - observations number, k - predictors number 
            # 4 * mean(vectors of values of cook's distance) (cách đang dùng)
      # as.numeric(): chuyển dữ liệu sang kiểu số 
coutliers
outliers = c(outliers , coutliers[ !coutliers %in% outliers ] ) # thêm vào outliers các hàng chứa influential observation chưa nằm trong outliers 

## làm sạch dữ liệu 
cleanredDat = redDat[-outliers, ] # DỮ LIỆU SẠCH 
model3 = lm(quality ~ ., data = cleanredDat)
t = summary(model3)
a = mean(t$residuals^2)

## đánh giá lại dữ liệu
# vẽ lại histogram để thấy các biểu đồ đã được đưa từ dạng lệch dương về dạng chuẩn 
oldpar = par(mfrow=c(3,4))
for ( i in 1:12 ) {
  truehist(cleanredDat[[i]], xlab = names(cleanredDat)[i], col = 'lightgreen', main = paste("Average =", signif(mean(cleanredDat[[i]]),3)))
}

testRegsubsets = function(dataset, yColName, methods, metrics) {
  # Perform the given best subset selection methods and plot the given corresponding model
  # metrics and the variable membership for each models
  #
  # Args:
  #   dataset: The data frame on which to perform subset selection methods
  #   yColName: The name of the outcome variable
  #   methods: Vector. The list of the subset selection methods to perform
  #   metrics: Vector. The list of metrics to plot
  #
  # Returns:
  #   Plot the given model metrics and the variable membership for each models
  summaryMetrics = NULL
  whichAll = list()
  for (myMthd in methods) {
    rsRes = regsubsets(dataset[, yColName]~ ., dataset[, -which(names(dataset) %in% yColName)], method = myMthd, nvmax = 11)
    summRes = summary(rsRes)
    whichAll[[myMthd]] = summRes$which
    for (metricName in metrics) {
      summaryMetrics = rbind(summaryMetrics,
                             data.frame(method = myMthd, metric = metricName,
                                        nvars = 1:length(summRes[[metricName]]),
                                        value = summRes[[metricName]]))
    }
  }
  
  # Plot variable membership for each models
  old.par = par(mfrow = c(1,2), ps = 16, mar = c(5,7,2,1))
  for (myMthd in names(whichAll)) {
    image(1:nrow(whichAll[[myMthd]]),
          1:ncol(whichAll[[myMthd]]),
          whichAll[[myMthd]], xlab = 'N(vars)', ylab = '',
          xaxt = 'n', yaxt = 'n', breaks = c(-0.5, 0.5, 1.5),
          col = c('white', 'lightblue1'), main = myMthd)
    axis(1, 1:nrow(whichAll[[myMthd]]), rownames(whichAll[[myMthd]]))
    axis(2, 1:ncol(whichAll[[myMthd]]), colnames(whichAll[[myMthd]]), las = 2)
  }
  par(old.par)
  
  # Plot the model metrics
  ggplot(summaryMetrics, aes(x = nvars, y = value, shape = method, colour = method)) + geom_path() + geom_point() + facet_wrap(~metric, scales = "free") + theme(legend.position = "top")
}

testRegsubsets(dataset = cleanredDat, yColName = "quality", methods = c("exhaustive", "backward", "forward"), metrics = c("rsq", "rss", "adjr2", "cp", "bic"))
